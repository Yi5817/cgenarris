#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "molecule_utils.h"
#include "pygenarris_mpi_utils.h"
#include "randomgen.h"

void print_time(void)
{
    time_t current_time = time(NULL);
    struct tm *loc_time;
    loc_time = localtime (&current_time);
    printf("The local time is now: %s", asctime (loc_time));
}

FILE* open_output_file(int my_rank)
{
    FILE *out_file = NULL;

    if (my_rank == 0)
    {
        out_file = fopen("geometry.out", "w");
        if(!out_file)       //check permissions
        {
            printf("***ERROR: cannot create geometry.out \n");
            exit(EXIT_FAILURE);
        }
    }

    return out_file;
}

void init_random_seed(unsigned int *seed, unsigned int *seed2, int random_seed, int rank)
{
    //random number seeding, different seeds for different threads
    if (random_seed == 0)
    {
        srand((unsigned int)time(NULL));
        random_seed = rand();
    }
    else
    {
        srand((unsigned int) 19023411);
    }

    *seed = (unsigned int)abs(rank*7 + random_seed);  //some random seed private for each threads
    *seed2 = (unsigned int)abs(rank*17 + random_seed);
    init_genrand(*seed);

}

void recenter_molecules(molecule* mol, int mol_types)
{
    for(int i = 0; i < mol_types; i++)
    {
        recenter_molecule(mol + i);
    }
}

float draw_volume(float volume_mean, float volume_std)
{
    float volume;

    do
    {
        volume = normal_dist_ab(volume_mean, volume_std);
    }while(volume < 1);

    return volume;
}

/*
Finds the number of atoms in each molecule from molecule array
and constructs n_atoms_in_mol array of length n_mol_types
*/
void get_n_atoms_in_mol(int *n_atoms_in_mol, molecule *mol, int n_mol_types)
{
    for(int m = 0; m < n_mol_types; m++)
    {
        n_atoms_in_mol[m] = (mol + m)->num_of_atoms;
    }
}


void print_allowed_spg(int *allowed_spg, int num_spg)
{
    printf("Detecting compatible spacegroups using only general Wyckoff positions:\n");
    printf("Number of allowed spg: %d\n", num_spg);
    for(int spg_id = 0; spg_id < num_spg; spg_id++)
    {
        int spg = allowed_spg[spg_id];
        printf("Spacegroup %d is compatible.\n", spg);
    }
    printf("\n");
}

/*
main structure generation loop
*/
int try_crystal_generation(cocrystal *cxtal,
                           Settings set,
                           molecule *mol,
                           float *volume,
                           long attempts,
                           long batch_size)
{
    // Loop over the batch. bat = batch attempt
    for(long bat = 0; bat < batch_size; bat++)
    {

        // Alignment failures
        if(!generate_cocrystal(cxtal, set, mol, volume))
            continue;

        // reset volume
        if( (attempts + bat) % set.vol_attempts == 0)
        {
            *volume = draw_volume(set.vol_mean, set.vol_std);
            fflush(stdout);
        }

        // Structure check
        int verdict = cxtal_check_structure(cxtal, &set);
        if(verdict)
        {
            printf("structure check passed\n");
            break;
        }
    }

}


/*
Checks if structure generation can be stopped.
Check if enough structures were generated. OR
ran out of attempts
*/
int check_stop_condition(int struct_counter, int max_struct,
                         long attempt, long max_attempt)
{
    if(struct_counter > max_struct)
        return ENOUGH_STOP;

    if(attempt > max_attempt)
    {
        printf("attempts = %ld\n", max_attempt );
        return ATTEMPTS_STOP;
    }

    return NO_STOP;
}


/*
Slave processes send structures to master rank
*/
int send_structures()
{
    return 1;
}

/*
Master rank write to output file
*/
int write_structures(cocrystal *cxtal, int *found_poll,
                     int *struct_count, int max_structs,
                     FILE *out_file, int total_ranks,
                     MPI_Comm world_comm)
{
    // Print structure generated by master
    if(found_poll[0])
    {
        cxtal_print(cxtal, out_file, 0);
        *struct_count++;
    }

    // Get structures from other ranks and write
    for(int rank = 1; rank < total_ranks; rank++)
    {
        if(found_poll[rank] == 1)
        {
            cxtal_receive(world_comm, rank, cxtal);
            if(*struct_count < max_structs)
            {
                cxtal_print(cxtal, out_file, 0);
                *struct_count++;
            }
        }
    }
}

/*
Print after Genarris exits
*/
void print_exit()
{
    printf("Genarris has completed generation.\n");
}

int cxtal_receive(MPI_Comm world_comm, cocrystal cxtal)
{
    return 1;
}