#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "cocrystal_utils.h"
#include "molecule_utils.h"
#include "pygenarris_mpi_utils.h"
#include "randomgen.h"
#include "spg_generation.h"

void print_time(void)
{
    time_t current_time = time(NULL);
    struct tm *loc_time;
    loc_time = localtime (&current_time);
    printf("The local time is now: %s", asctime (loc_time));
}

FILE* open_output_file(int my_rank)
{
    FILE *out_file = NULL;

    if (my_rank == 0)
    {
        out_file = fopen("geometry.out", "w");
        if(!out_file)       //check permissions
        {
            printf("***ERROR: cannot create geometry.out \n");
            exit(EXIT_FAILURE);
        }
    }

    return out_file;
}

void init_random_seed(unsigned int *seed, unsigned int *seed2, int random_seed, int rank)
{
    //random number seeding, different seeds for different threads
    if (random_seed == 0)
    {
        srand((unsigned int)time(NULL));
        random_seed = rand();
    }
    else
    {
        srand((unsigned int) 19023411);
    }

    *seed = (unsigned int)abs(rank*7 + random_seed);  //some random seed private for each threads
    *seed2 = (unsigned int)abs(rank*17 + random_seed);
    init_genrand(*seed);

}

void recenter_molecules(molecule* mol, int mol_types)
{
    for(int i = 0; i < mol_types; i++)
    {
        recenter_molecule(mol + i);
    }
}

float draw_volume(float volume_mean, float volume_std)
{
    float volume;

    do
    {
        volume = normal_dist_ab(volume_mean, volume_std);
    }while(volume < 1);

    return volume;
}

/*
Finds the number of atoms in each molecule from molecule array
and constructs n_atoms_in_mol array of length n_mol_types
*/
void get_n_atoms_in_mol(int *n_atoms_in_mol, molecule *mol, int n_mol_types)
{
    for(int m = 0; m < n_mol_types; m++)
    {
        n_atoms_in_mol[m] = (mol + m)->num_of_atoms;
    }
}


void print_allowed_spg(int *allowed_spg, int num_spg)
{
    printf("Detecting compatible spacegroups using only general Wyckoff positions:\n");
    printf("Number of allowed spg: %d\n", num_spg);
    for(int spg_id = 0; spg_id < num_spg; spg_id++)
    {
        int spg = allowed_spg[spg_id];
        printf("Spacegroup %d is compatible.\n", spg);
    }
    printf("\n");
}

/*
main structure generation loop
*/
int try_crystal_generation(cocrystal *cxtal,
                           Settings set,
                           molecule *mol,
                           float *volume,
                           long attempts,
                           long batch_size)
{
    // Loop over the batch. bat = batch attempt
    //printf("starting batch %d\n", attempts);
    for(long bat = 0; bat < batch_size; bat++)
    {

        // Alignment failures
        if(!generate_cocrystal(cxtal, set, mol, volume))
            continue;

        // reset volume
        if( (attempts + bat) % set.vol_attempts == 0)
        {
            *volume = draw_volume(set.vol_mean, set.vol_std);
            //printf("draing new vol - total attempts = %ld\n", attempts+bat);
            fflush(stdout);
        }

        // Structure check
        int verdict = cxtal_check_structure(cxtal, &set);
        if(verdict)
        {
	  //printf("structure check passed\n");
            return 1;
        }
    }
    //printf("Completed try_crystal_generation\n");
    fflush(stdout);
    return 0;
}


/*
Checks if structure generation can be stopped.
Check if enough structures were generated. OR
ran out of attempts
*/
int check_stop_condition(int struct_counter, int max_struct,
                         long attempt, long max_attempt)
{
    if(struct_counter >= max_struct)
        return ENOUGH_STOP;

    if(attempt >= max_attempt)
    {
        printf("attempts = %ld, max_attempts = %ld\n", attempt, max_attempt);
        return ATTEMPTS_STOP;
    }

    return NO_STOP;
}


/*
Slave processes send structures to master rank
*/
void send_structures(cocrystal *cxtal, int verdict, MPI_Comm comm)
{
    if(verdict)
        cxtal_send(comm, cxtal, 0);
}

/*
Master rank write to output file
*/
void write_structures(cocrystal *cxtal, int *found_poll, int *struct_count,
                     int max_structs, FILE *out_file, int total_ranks,
                     MPI_Comm comm)
{
    // Print structure generated by master
    if(found_poll[0])
    {
        if(*struct_count < max_structs)
        {    (*struct_count)++;
             cxtal_print(cxtal, out_file, 0);
        }
    }

    // Get structures from other ranks and write
    for(int rank = 1; rank < total_ranks; rank++)
    {
        if(found_poll[rank] == 1)
        {
            printf("recceing structs\n");
            cxtal_receive(comm, rank, cxtal);
            if(*struct_count < max_structs)
            {
                cxtal_print(cxtal, out_file, 0);
                (*struct_count)++;
            }
        }
    }
}

/*
Print after Genarris exits
*/
void print_exit()
{
    printf("Genarris has completed generation.\n");
}


void cxtal_receive(MPI_Comm comm, int from, cocrystal *cxtal)
{
    MPI_Status status;

    MPI_Recv(&(cxtal->n_atoms), 1, MPI_INT, from, 1, comm, &status);
    MPI_Recv(&(cxtal->n_mols), 1, MPI_INT, from, 2, comm, &status);
    MPI_Recv(&(cxtal->n_mol_types), 1, MPI_INT, from, 3, comm, &status);
    MPI_Recv(&(cxtal->spg), 1, MPI_INT, from, 4, comm, &status);
    MPI_Recv(&(cxtal->Z), 1, MPI_INT, from, 5, comm, &status);
    MPI_Recv(&(cxtal->Zp), 1, MPI_INT, from, 6, comm, &status);

    int N = cxtal->n_atoms;
    int M1 = cxtal->n_mols;
    int M2 = cxtal->n_mol_types;
    MPI_Recv(cxtal->lattice_vectors, 9, MPI_FLOAT, from, 7, comm, &status);
    MPI_Recv(cxtal->Xcord, N, MPI_FLOAT, from, 8, comm, &status);
    MPI_Recv(cxtal->Ycord, N, MPI_FLOAT, from, 9, comm, &status);
    MPI_Recv(cxtal->Zcord, N, MPI_FLOAT, from, 10, comm, &status);
    MPI_Recv(cxtal->atoms, 2*N, MPI_CHAR, from, 11, comm, &status);
    MPI_Recv(cxtal->com, 3*M1, MPI_FLOAT, from, 12, comm, &status);
    MPI_Recv(cxtal->mol_index, M1, MPI_INT, from, 13, comm, &status);
    MPI_Recv(cxtal->mol_types, M1, MPI_INT, from, 14, comm, &status);
    MPI_Recv(cxtal->n_atoms_in_mol, M2, MPI_INT, from, 15, comm, &status);
    MPI_Recv(cxtal->wyckoff_position, M2, MPI_INT, from, 16, comm, &status);
    MPI_Recv(cxtal->stoic, M2, MPI_INT, from, 17, comm, &status);
}


void cxtal_send(MPI_Comm comm, cocrystal *cxtal, int to)
{

    MPI_Send(&(cxtal->n_atoms), 1, MPI_INT, to, 1, comm);
    MPI_Send(&(cxtal->n_mols), 1, MPI_INT, to, 2, comm);
    MPI_Send(&(cxtal->n_mol_types), 1, MPI_INT, to, 3, comm);
    MPI_Send(&(cxtal->spg), 1, MPI_INT, to, 4, comm);
    MPI_Send(&(cxtal->Z), 1, MPI_INT, to, 5, comm);
    MPI_Send(&(cxtal->Zp), 1, MPI_INT, to, 6, comm);

    int N = cxtal->n_atoms;
    int M1 = cxtal->n_mols;
    int M2 = cxtal->n_mol_types;
    MPI_Send(cxtal->lattice_vectors, 9, MPI_FLOAT, to, 7, comm);
    MPI_Send(cxtal->Xcord, N, MPI_FLOAT, to, 8, comm);
    MPI_Send(cxtal->Ycord, N, MPI_FLOAT, to, 9, comm);
    MPI_Send(cxtal->Zcord, N, MPI_FLOAT, to, 10, comm);
    MPI_Send(cxtal->atoms, 2*N, MPI_CHAR, to, 11, comm);
    MPI_Send(cxtal->com, 3*M1, MPI_FLOAT, to, 12, comm);
    MPI_Send(cxtal->mol_index, M1, MPI_INT, to, 13, comm);
    MPI_Send(cxtal->mol_types, M1, MPI_INT, to, 14, comm);
    MPI_Send(cxtal->n_atoms_in_mol, M2, MPI_INT, to, 15, comm);
    MPI_Send(cxtal->wyckoff_position, M2, MPI_INT, to, 16, comm);
    MPI_Send(cxtal->stoic, M2, MPI_INT, to, 17, comm);

    //cxtal_print(cxtal,stdout, 0);
}
